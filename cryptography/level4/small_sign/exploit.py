import re

# parse primes 
primes = []
with open("primes1.txt") as file:
    for line in file:
        primes += [int(num) for num in line.split()]

# parse N, e, and signatures
text = open("data.txt").read()
N = [int(n) for n in re.findall(r'N:\s([0-9]+)', text)][0]
e = [int(e) for e in re.findall(r'e:\s([0-9]+)', text)][0]
signatures = [int(s) for s in re.findall(r'Signature:\s([0-9]+)', text)]

# create ref dict
ref = dict(zip(primes[0:len(signatures)],signatures))

# works for small n only
# hardcoded to limit to amount of cached primes
# so that failure is ensured if not factorizable
# in terms of said primes
def prime_fac(n):
    fac = {}
    for p in primes[0:len(signatures)]:
        while n % p == 0:
            n //= p
            if p in fac:
                fac[p] += 1
            else:
                fac.update({p:1})
    return fac

# get challenge value and attempt to factorize
value = int(input("input value: "))
value_fac = prime_fac(value)

# compute product of "alleged factorization" of the challenge
product = 1
for k in value_fac.keys():
    product *= k ** value_fac[k]

# if the factorization has succeeded, compute the rsa signature
if product == value:
    print(value_fac)
    msg = 1
    # compute the rsa sig by the multiplicative
    # property of rsa, using the dictionary of
    # primes and their respective signatures
    for k in value_fac.keys():
        for i in range(0, value_fac[k]):
            msg *= ref[k]
            msg %= N
    print(msg)
else:
    print("factorization failed")
    print(value_fac)
